typedef struct {
} mBlank;

// screen header
// screen.type == 0x0e000000
typedef struct {
    USHORT foo_1 <format=hex, bgcolor=cLtRed>;
    USHORT type <bgcolor=cLtGreen>;
    switch (type) {
        case 0x0000:
            UBYTE foo[15] <format=hex, bgcolor=cLtRed>;
            break;
        case 0x6400:
            UBYTE foo[21] <format=hex, bgcolor=cLtRed>;
            break;
    }
    USHORT background <format=hex>;
} mScreenHeaderType1 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x04000001
typedef struct {
    UBYTE foo[27] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType2 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x05000001
typedef struct {
    UBYTE foo[59] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType3 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x0a000001
typedef struct {
    UBYTE foo[62] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType4 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x0b000001
typedef struct {
    UBYTE foo[23] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType5 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x0e000001
typedef struct {
    UBYTE foo_1 <format=hex, bgcolor=cLtRed>;
    USHORT type <format=hex, bgcolor=cLtGreen>;
    switch (type) {
        case 0x0001:
            USHORT parent <format=hex>;
            UBYTE foo[12] <format=hex, bgcolor=cLtRed>;
            break;
        case 0x0012:
            UBYTE foo[12] <format=hex, bgcolor=cLtRed>;
            break;
    }
} mScreenHeaderType6 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x00310100
typedef struct {
    UBYTE foo[38] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType7 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x00320100
typedef struct {
    if (offsetIndex < 209) {
        UBYTE foo[16] <format=hex, bgcolor=cLtRed>;
    }
    else {
        UBYTE foo[10] <format=hex, bgcolor=cLtRed>;
    }
} mScreenHeaderType8 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x00330100
typedef struct {
    UBYTE foo[44] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType9 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x00310101
typedef struct {
    UBYTE foo[18] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType10 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x00320101
typedef struct {
    if (offsetIndex < 49) {
        UBYTE foo[12] <format=hex, bgcolor=cLtRed>;
    }
    else {
        UBYTE foo[10] <format=hex, bgcolor=cLtRed>;
    }
} mScreenHeaderType11 <bgcolor=cLtGreen>;

// screen header
// screen.type == 0x00330101
typedef struct {
    UBYTE foo[8] <format=hex, bgcolor=cLtRed>;
} mScreenHeaderType12 <bgcolor=cLtGreen>;



// oblasti
typedef struct {
    USHORT type <format=hex, bgcolor=cBlue, fgcolor=cWhite>;
    switch (type) {

        // hlavni oblast
        case 0x0004:
            USHORT topleft_x;
            USHORT topleft_y;
            USHORT width;
            USHORT height;
            USHORT slider_topleft_x;
            USHORT slider_topleft_y;
            USHORT slider_height;
            UBYTE textfile_length;
            CHAR textfile[textfile_length];
            USHORT foo_1 <format=hex, bgcolor=cLtRed>;
            break;

        // tlacitko
        case 0x0009:
            USHORT id;
            USHORT image;
            USHORT foo_1 <format=hex, bgcolor=cLtRed>;
            USHORT topleft_x;
            USHORT topleft_y;
            USHORT scancode;
            USHORT hover_topleft_x;
            USHORT hover_topleft_y;
            USHORT hover_bottomright_x;
            USHORT hover_bottomright_y;
            UBYTE foo_2 <format=hex, bgcolor=cLtRed>;
            break;

        // unknown - issue 1
        case 0x000a:
            UBYTE foo[11] <format=hex, bgcolor=cLtRed>;
            break;

        // konec sekce
        case 0x000b:
            UBYTE foo[14] <format=hex, bgcolor=cLtRed>;
            break;

        // unknown - issue 1
        case 0x000e:
            UBYTE foo_1[6] <format=hex, bgcolor=cLtRed>;
            UBYTE flag <format=hex>;
            if (flag == 0x41) {
                local int counter_foo = 0;
                do {
                    counter_foo++;
                    USHORT foo_2 <format=hex, bgcolor=cLtRed>;
                } while (foo_2[counter_foo - 1] != 0xffff);
            }
            else {
                CHAR textfile[flag];
                UBYTE foo_2 <format=hex, bgcolor=cLtRed>;
            }
            break;

        // tlacitko slideru
        case 0x0011:
            USHORT topleft_x;
            USHORT topleft_y;
            USHORT image;
            USHORT foo_1 <format=hex, bgcolor=cLtRed>;
            USHORT scancode;
            break;

        // reklama
        case 0x0015:
            USHORT topleft_x;
            USHORT topleft_y;
            USHORT bottomright_x;
            USHORT bottomright_y;
            USHORT image;
            USHORT id;
            break;

        // unknown
        case 0x0024:
            UBYTE foo[4] <format=hex, bgcolor=cLtRed>;
            break;

        // unknown - nasleduji akce!
        case 0x0041:
            UBYTE foo[24] <format=hex, bgcolor=cLtRed>;
            break;

        // unknown
        case 0x0063:
            UBYTE foo_1[4] <format=hex, bgcolor=cLtRed>;
            USHORT flag <format=hex>;
            UBYTE foo_2[2] <format=hex, bgcolor=cLtRed>;
            if (flag == 0x0001) {
                UBYTE textfile_length;
                CHAR textfile[textfile_length];
                UBYTE foo_3[3] <format=hex, bgcolor=cLtRed>;
            }
            else {
                UBYTE foo_3[6] <format=hex, bgcolor=cLtRed>;
            }
            break;

        // unknown
        case 0x07d2:
            UBYTE foo[15] <format=hex, bgcolor=cLtRed>;
            break;
    }
} mScreenArea <bgcolor=cAqua>;



// akce
typedef struct {
    USHORT binding <format=hex, bgcolor=cBlue, fgcolor=cWhite>;
    if (binding != 0xffff) {
        USHORT datalength <bgcolor=cDkAqua>;
        UBYTE data[datalength - 4];
//        FSkip(datalength - 4);
//        switch (type) {
//            case 0xffff:
//                break;
//        }
    }
} mScreenAction <bgcolor=cAqua>;



typedef struct {
    local UINT thisOffset = offsetIndex;
    UINT type <format=hex>;
    switch (type) {

        // oblasti
        // issue 00: screen 0-13
        case 0x0e000000:
            mScreenHeaderType1 header;
            local int counter = 0;
            do {
                counter++;
                mScreenArea area;
            } while (area[counter - 1].type != 0x000b);
            break;

        // odkazy
        // issue 00: screen 14-16
        case 0x04000001:
            mScreenHeaderType2 header;
            local int counter = 0;
            do {
                counter++;
                mScreenAction action;
            } while (action[counter - 1].binding != 0xffff);
            break;

        // odkazy
        // issue 00: screen 17-19
        case 0x05000001:
            mScreenHeaderType3 header;
            local int counter = 0;
            do {
                counter++;
                mScreenAction action;
            } while (action[counter - 1].binding != 0xffff);
            break;

        // odkazy
        // issue 00: screen 20
        case 0x0a000001:
            mScreenHeaderType4 header;
            local int counter = 0;
            do {
                counter++;
                mScreenAction action;
            } while (action[counter - 1].binding != 0xffff);
            break;

        // odkazy
        // issue 00: screen 21
        case 0x0b000001:
            mScreenHeaderType5 header;
            break;

        // odkazy
        // issue 00: screen 22-35
        case 0x0e000001:
            mScreenHeaderType6 header;
            local int counter = 0;
            do {
                counter++;
                mScreenAction action;
            } while (action[counter - 1].binding != 0xffff);
            break;

        // oblasti
        // issue 01: screen 0
        // issue 02: screen 0
        // issue 03: screen 0
        // issue 04: screen 0
        // issue 05: screen 0
        // issue 06: screen 0
        // issue 07: screen 0
        // issue 08: screen 0
        // issue 09: screen 0
        // issue 10: screen 0
        case 0x00310100:
            mScreenHeaderType7 header;
            local int counter = 0;
            do {
                counter++;
                mScreenArea area;
            } while (area[counter - 1].type != 0x000b);
            break;

        // oblasti
        // issue 01: screen 1-12, 209
        // issue 02: screen 1-12, 209
        // issue 03: screen 1-12, 209
        // issue 04: screen 1-12, 209
        // issue 05: screen 1-12, 209
        // issue 06: screen 1-12, 209
        // issue 07: screen 1-12, 209
        // issue 08: screen 1-12, 209
        // issue 09: screen 1-12, 209
        // issue 10: screen 1-12, 209
        case 0x00320100:
            mScreenHeaderType8 header;
            local int counter = 0;
            do {
                counter++;
                mScreenArea area;
            } while (area[counter - 1].type != 0x000b);
            break;

        // oblasti
        // issue 01: screen 13, 199
        // issue 02: screen 13, 199
        // issue 03: screen 13, 199
        // issue 04: screen 13, 199
        // issue 05: screen 13, 199
        // issue 06: screen 13, 199
        // issue 07: screen 13, 199, 252
        // issue 08: screen 13, 199, 252
        // issue 09: screen 13, 199, 252
        // issue 10: screen 13, 199, 252
        case 0x00330100:
            mScreenHeaderType9 header;
            local int counter = 0;
            do {
                counter++;
                mScreenArea area;
            } while (area[counter - 1].type != 0xffff);
            counter = 0;
            do {
                counter++;
                mScreenAction action;
            } while (action[counter - 1].binding != 0xffff);
            break;

        // odkazy
        // issue 01: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 02: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 03: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 04: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 05: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 06: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 07: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 08: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 09: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        // issue 10: screen 14, 19-30, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159
        case 0x00320101:
            mScreenHeaderType11 header;
            if (offsetIndex < 49) {
                local int counter = 0;
                do {
                    counter++;
                    mScreenAction action;
                } while (action[counter - 1].binding != 0xffff);
            }
            else {
                local int counter = 0;
                do {
                    counter++;
                    mScreenArea area;
                } while (area[counter - 1].type != 0x000b);
            }
            break;

        // odkazy
        // issue 01: screen 48
        // issue 02: screen 48
        // issue 03: screen 48
        // issue 04: screen 48
        // issue 05: screen 48
        // issue 06: screen 48
        // issue 07: screen 48
        // issue 08: screen 48
        // issue 09: screen 48
        // issue 10: screen 48
        case 0x00310101:
            mScreenHeaderType10 header;
            local int counter = 0;
            do {
                counter++;
                mScreenAction action;
            } while (action[counter - 1].binding != 0xffff);
            break;

        // odkazy
        // issue 01: screen 198, 200-208, 219
        // issue 02: screen 198, 200-208, 219, 247
        // issue 03: screen 198, 200-208, 219, 247, 248
        // issue 04: screen 198, 200-208, 219, 247, 248
        // issue 05: screen 198, 200-208, 219, 247, 248
        // issue 06: screen 198, 200-208, 219, 247, 248
        // issue 07: screen 198, 200-208, 218, 219, 246-248
        // issue 08: screen 198, 200-208, 218, 219, 246-248
        // issue 09: screen 198, 200-208, 218, 219, 246-248
        // issue 10: screen 198, 200-208, 218, 219, 246-248
        case 0x00330101:
//            mScreenHeaderType12 header;
//            local int counter = 0;
//            do {
//                counter++;
//                mScreenAction action;
//            } while (action[counter - 1].binding != 0xffff);
            local int counter = 0;
            do {
                counter++;
                mScreenArea area;
            } while (area[counter - 1].type != 0x000b);
            break;
    }
} mScreen <bgcolor=cGreen, comment=GetScreenType>;



string GetScreenType(mScreen &screen) {
//    return screen.type;
    string s;
    SPrintf(s, "0x%08x", (int)screen.type);
    return s;
}



UINT foo_1 <format=hex, bgcolor=cLtRed>;

// issue 0-10
UINT screenOffsets[255] <format=hex, bgcolor=cLtPurple>;

// issue 11+
//UINT screenOffsets[1023] <format=hex, bgcolor=cLtPurple>;

local UINT offsetIndex;
local UINT offset;
for (offsetIndex = 0; offsetIndex < 255; offsetIndex++) {
    offset = screenOffsets[offsetIndex];
    if (offset < 0xFFFFFFFF) {
        FSeek(offset);
        mScreen screen;
    }
    else {
        mBlank screen;
    }
}
